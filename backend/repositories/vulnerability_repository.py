"""Vulnerability repository for database operations."""
from typing import Optional, List, Dict, Any
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, func

from core.models import Vulnerability, ScanResult, User
from core.schemas import VulnerabilitySeverity, VulnerabilityStatus, PaginationParams


class VulnerabilityRepository:
    """Repository for vulnerability database operations."""
    
    def __init__(self, db: Session):
        self.db = db
    
    def create(self, vuln_data: Dict[str, Any]) -> Vulnerability:
        """Create a new vulnerability."""
        db_vuln = Vulnerability(**vuln_data)
        self.db.add(db_vuln)
        self.db.commit()
        self.db.refresh(db_vuln)
        
        return db_vuln
    
    def get_by_id(self, vuln_id: int) -> Optional[Vulnerability]:
        """Get vulnerability by ID."""
        return self.db.query(Vulnerability).filter(Vulnerability.id == vuln_id).first()
    
    def get_scan_vulnerabilities(
        self,
        scan_id: str,
        pagination: PaginationParams,
        severity: Optional[VulnerabilitySeverity] = None,
        status: Optional[VulnerabilityStatus] = None
    ) -> List[Vulnerability]:
        """Get vulnerabilities for a specific scan."""
        query = self.db.query(Vulnerability).filter(Vulnerability.scan_id == scan_id)
        
        if severity:
            query = query.filter(Vulnerability.severity == severity)
        
        if status:
            query = query.filter(Vulnerability.status == status)
        
        return query.order_by(Vulnerability.created_at.desc()).offset(
            (pagination.page - 1) * pagination.per_page
        ).limit(pagination.per_page).all()
    
    def get_user_vulnerabilities(
        self,
        user_id: int,
        pagination: PaginationParams,
        severity: Optional[VulnerabilitySeverity] = None,
        status: Optional[VulnerabilityStatus] = None,
        vuln_type: Optional[str] = None
    ) -> List[Vulnerability]:
        """Get vulnerabilities reported by or assigned to a user."""
        query = self.db.query(Vulnerability).filter(
            or_(Vulnerability.reported_by == user_id, Vulnerability.assigned_to == user_id)
        )
        
        if severity:
            query = query.filter(Vulnerability.severity == severity)
        
        if status:
            query = query.filter(Vulnerability.status == status)
        
        if vuln_type:
            query = query.filter(Vulnerability.type == vuln_type)
        
        return query.order_by(Vulnerability.created_at.desc()).offset(
            (pagination.page - 1) * pagination.per_page
        ).limit(pagination.per_page).all()
    
    def get_all_vulnerabilities(
        self,
        pagination: PaginationParams,
        severity: Optional[VulnerabilitySeverity] = None,
        status: Optional[VulnerabilityStatus] = None,
        vuln_type: Optional[str] = None,
        scan_id: Optional[str] = None,
        target: Optional[str] = None
    ) -> List[Vulnerability]:
        """Get all vulnerabilities with optional filtering."""
        query = self.db.query(Vulnerability)
        
        if severity:
            query = query.filter(Vulnerability.severity == severity)
        
        if status:
            query = query.filter(Vulnerability.status == status)
        
        if vuln_type:
            query = query.filter(Vulnerability.type == vuln_type)
        
        if scan_id:
            query = query.filter(Vulnerability.scan_id == scan_id)
        
        if target:
            query = query.filter(Vulnerability.target.ilike(f"%{target}%"))
        
        return query.order_by(Vulnerability.created_at.desc()).offset(
            (pagination.page - 1) * pagination.per_page
        ).limit(pagination.per_page).all()
    
    def update(self, vuln_id: int, update_data: Dict[str, Any]) -> Optional[Vulnerability]:
        """Update vulnerability."""
        db_vuln = self.get_by_id(vuln_id)
        if not db_vuln:
            return None
        
        for field, value in update_data.items():
            if hasattr(db_vuln, field):
                setattr(db_vuln, field, value)
        
        from datetime import datetime
        db_vuln.updated_at = datetime.utcnow()
        
        self.db.commit()
        self.db.refresh(db_vuln)
        
        return db_vuln
    
    def assign_to_user(self, vuln_id: int, user_id: int) -> Optional[Vulnerability]:
        """Assign vulnerability to a user."""
        return self.update(vuln_id, {"assigned_to": user_id})
    
    def change_status(self, vuln_id: int, status: VulnerabilityStatus) -> Optional[Vulnerability]:
        """Change vulnerability status."""
        return self.update(vuln_id, {"status": status})
    
    def get_vulnerability_statistics(self, user_id: Optional[int] = None) -> Dict[str, Any]:
        """Get vulnerability statistics."""
        query = self.db.query(Vulnerability)
        
        if user_id:
            query = query.filter(
                or_(Vulnerability.reported_by == user_id, Vulnerability.assigned_to == user_id)
            )
        
        total_vulns = query.count()
        
        # By severity
        severity_stats = self.db.query(
            Vulnerability.severity,
            func.count(Vulnerability.id)
        ).filter(
            or_(Vulnerability.reported_by == user_id, Vulnerability.assigned_to == user_id) if user_id else True
        ).group_by(Vulnerability.severity).all()
        
        # By status
        status_stats = self.db.query(
            Vulnerability.status,
            func.count(Vulnerability.id)
        ).filter(
            or_(Vulnerability.reported_by == user_id, Vulnerability.assigned_to == user_id) if user_id else True
        ).group_by(Vulnerability.status).all()
        
        # By type
        type_stats = self.db.query(
            Vulnerability.type,
            func.count(Vulnerability.id)
        ).filter(
            or_(Vulnerability.reported_by == user_id, Vulnerability.assigned_to == user_id) if user_id else True
        ).group_by(Vulnerability.type).all()
        
        # Critical vulnerabilities
        critical_vulns = query.filter(Vulnerability.severity == VulnerabilitySeverity.CRITICAL).count()
        
        # Open vulnerabilities
        open_vulns = query.filter(Vulnerability.status == VulnerabilityStatus.OPEN).count()
        
        return {
            "total_vulnerabilities": total_vulns,
            "critical_vulnerabilities": critical_vulns,
            "open_vulnerabilities": open_vulns,
            "by_severity": dict(severity_stats),
            "by_status": dict(status_stats),
            "by_type": dict(type_stats)
        }
    
    def get_critical_vulnerabilities(self, limit: int = 10) -> List[Vulnerability]:
        """Get critical vulnerabilities."""
        return self.db.query(Vulnerability).filter(
            Vulnerability.severity == VulnerabilitySeverity.CRITICAL,
            Vulnerability.status == VulnerabilityStatus.OPEN
        ).order_by(Vulnerability.created_at.desc()).limit(limit).all()
    
    def get_unassigned_vulnerabilities(self, limit: int = 20) -> List[Vulnerability]:
        """Get unassigned vulnerabilities."""
        return self.db.query(Vulnerability).filter(
            Vulnerability.assigned_to.is_(None),
            Vulnerability.status == VulnerabilityStatus.OPEN
        ).order_by(Vulnerability.severity.desc(), Vulnerability.created_at.desc()).limit(limit).all()
    
    def search(self, query: str, pagination: PaginationParams) -> List[Vulnerability]:
        """Search vulnerabilities by title, description, or target."""
        search_filter = or_(
            Vulnerability.title.ilike(f"%{query}%"),
            Vulnerability.description.ilike(f"%{query}%"),
            Vulnerability.target.ilike(f"%{query}%"),
            Vulnerability.type.ilike(f"%{query}%")
        )
        
        return self.db.query(Vulnerability).filter(search_filter).order_by(
            Vulnerability.created_at.desc()
        ).offset(
            (pagination.page - 1) * pagination.per_page
        ).limit(pagination.per_page).all()
    
    def count(self, user_id: Optional[int] = None, status: Optional[VulnerabilityStatus] = None) -> int:
        """Count vulnerabilities with optional filtering."""
        query = self.db.query(Vulnerability)
        
        if user_id:
            query = query.filter(
                or_(Vulnerability.reported_by == user_id, Vulnerability.assigned_to == user_id)
            )
        
        if status:
            query = query.filter(Vulnerability.status == status)
        
        return query.count()
    
    def delete(self, vuln_id: int) -> bool:
        """Delete a vulnerability."""
        db_vuln = self.get_by_id(vuln_id)
        if not db_vuln:
            return False
        
        self.db.delete(db_vuln)
        self.db.commit()
        
        return True
